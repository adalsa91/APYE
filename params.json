{
  "name": "APYE",
  "tagline": "Proyecto para la asignatura de Infraestructura Virtual 2016-2017",
  "body": "# APYE\r\n\r\n[![Build Status](https://travis-ci.org/adalsa91/APYE.svg?branch=master)](https://travis-ci.org/adalsa91/APYE)\r\n\r\nProyecto para la asignatura de Infraestructura Virtual 2016-2017\r\n\r\n### [Ejercicios Tema 2](https://github.com/adalsa91/EjercicioIV/blob/master/Tema2.md)\r\n\r\n##Descripción\r\nLa aplicación consiste en un gestor de ficheros que junto a un editor de texto permitirá al usuario la creación y edición de scripts de python, quedando estos almacenados permanentemente entre sesiones, posibilitando la opción de ejecutar estos scripts en un entorno virtual y seguro que devolverá los resultados del programa en pantalla.\r\n\r\n#Hito 2: Integración continua\r\n##Requisitos\r\nPara la descripción de las dependencias de la aplciación se ha creado un archivo *requeriments.txt* que suele ser el nombre usado por convención en Python.\r\n```\r\nclick==6.6\r\nFlask==0.11.1\r\ngunicorn==19.6.0\r\nitsdangerous==0.24\r\nJinja2==2.8\r\nMarkupSafe==0.23\r\nWerkzeug==0.11.11\r\npsycopg2==2.6.2\r\nSQLAlchemy==1.1.2\r\nFlask-SQLAlchemy==2.1\r\nFlask-Migrate==2.0.0\r\nFlask-Testing==0.6.1\r\nFlask-Login==0.4.0\r\nFlask-WTF==0.13.1\r\nWTForms==2.1\r\n\r\n```\r\n##Tests\r\nPara asegurar el correcto funcionamiento de la aplicación antes de ser desplegada se han escrito los siguientes tests. Para la automatización de los test se ha usado el framework de test **unittest** de Python, que además de orquestar la ejecución de los test proporciona una clase base llamada *TestCase* que podemos usar para crear nuevos casos de prueba, esta clase incluye métodos como **setUp* o *tearDown* que permiten configurar un entorno funcional para la realización de los test y limpiarlo todo tras las pruebas.\r\n\r\n```python\r\nimport unittest\r\nimport os\r\nimport shutil\r\nfrom app import app, db\r\nfrom models import User\r\nfrom flask_login import current_user\r\n\r\n\r\nclass ApyeTestCase(unittest.TestCase):\r\n    \"\"\"A base test case for flask-tracking.\"\"\"\r\n\r\n    def create_app(self):\r\n        app.config.from_object('config.TestConfiguration')\r\n        return app\r\n\r\n    def setUp(self):\r\n        db.session.close()\r\n        db.drop_all()\r\n        db.create_all()\r\n        self.app = app.test_client()\r\n        if not os.path.exists('users/'):\r\n            os.makedirs('users/')\r\n\r\n    def tearDown(self):\r\n        db.session.remove()\r\n        db.drop_all()\r\n        shutil.rmtree('users')\r\n\r\n    def test_adduser(self):\r\n        usuario = User('adrian', 'adalsa@correo.ugr.es',\r\n                       'password', 'Adrian', True)\r\n        db.session.add(usuario)\r\n        db.session.commit()\r\n        usuarios = User.query.all()\r\n        assert usuario in usuarios\r\n        print(\"[OK] Usuario creado satisfactoriamente\\n\")\r\n\r\n    def test_home_user(self):\r\n        if not os.path.exists('users/' + 'adrian'):\r\n            os.makedirs('users/' + 'adrian')\r\n        f = open('users/adrian/Welcome', 'w+')\r\n        f.write('Welcome!')\r\n        f.seek(0)\r\n        assert f.read() == 'Welcome!'\r\n        f.close()\r\n        print(\"[OK] Entorno de usuario creado correctamente\\n\")\r\n\r\n    def test_login_logout(self):\r\n        usuario = User('jorge', 'jorge@correo.ugr.es',\r\n                       'password', 'Jorge Nitales', True)\r\n        db.session.add(usuario)\r\n        db.session.commit()\r\n\r\n        with self.app:\r\n            # Login\r\n            response = self.app.post(\r\n                '/login', data={'username': 'jorge', 'password': 'password'},\r\n                follow_redirects=True)\r\n            assert current_user.username == 'jorge'\r\n            assert b'Success' in response.data\r\n\r\n            # Logout\r\n            response = self.app.post(\r\n                '/logout', follow_redirects=True)\r\n            assert current_user.is_anonymous\r\n\r\n        print(\"[OK] Usuarios registrados pueden identificarse correctamente\")\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n\r\n```\r\n\r\nPara ejecutar los tests utilizamos la función **discover** de *unittest*:\r\n\r\n```bash\r\n\tpython -m unittest discover\r\n\r\n```\r\n\r\nEste comando busca recursivamente tests desde el directorio en el que lo lanzamos.\r\n\r\n![Resultados tests](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito2/image1.png \"Resultados tests\")\r\n\r\nPara simplificar el lanzamiento de tests y otras tareas creamos un **Makefile**:\r\n\r\n```make\r\ninstall:\r\n\tpip install -r requirements.txt\r\n\r\ntest:\r\n\tpython -m unittest discover\r\n\r\nrun:\t\r\n\tpython manage.py runserver\r\n\t\r\n```\r\n\r\n##Integración Continua\r\n\r\nPara este paso usamos el sistema de integración continua **Travis**, el mótivo de la elección es debido a su popularidad y documentación.\r\n\r\nEl primer paso es sincronizar *Travis* con nuestro *GitHub*, para ello iniciamos sesión en *Travis* con nuestra cuenta de *GitHub* y activamos el repositorio que queremos conectar en la página de nuestro perfil de *Travis*.\r\n\r\n![Activación repositorio en perfil Travis](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito2/image2.png \"Activación repositorio en perfil Travis\")\r\n\r\nA continuación creamos el archivo `.travis.yml` en el que especificaremosel lenguaje y versión usados, además de otros datos necesarios para construir el entorno de ejecución y el comando para ejecutar los tests.\r\n\r\n```make\r\nlanguage: python\r\npython:\r\n  - \"3.4\"\r\n\r\ninstall: \"pip install -r requirements.txt\"\r\n\r\nservices:\r\n  postgresql\r\n\r\nbefore_script:\r\n  - psql -c \"create user apye with password 'iDDLpkP1uv' \" -U postgres\r\n  - psql -c \"create database apye_users;\" -U postgres\r\n  - psql -c \"grant all privileges on database apye_users to apye;\" -U postgres\r\n  - python manage.py db upgrade\r\n\r\nscript: python test_base.py\r\n\r\n\r\n```\r\n\r\nTambién necesitaremos definir las variables de entorno necsarias para la aplicación, podemos hacerlo en el fichero anterior o en la interfaz web.\r\n\r\n![Variables de entorno en Travis](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito2/image3.png \"Variables de entorno en Travis\")\r\n\r\nUna vez todo esté configurado hacemos un add --> commit --> push y Travis detectará los cambios en nuestro repositorio de GitHub y lanzará los tests. Podemos comprobar el resultado en la página web de *Travis*.\r\n![Build History](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito2/image4.png \"Build History\")\r\n\r\n![Log Travis](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito2/image5.png \"Log Travis\")\r\n\r\nAdemás Travis nos ofrece un incrustable que demuestra el estado actual del repositorio.\r\n\r\n[![Build Status](https://travis-ci.org/adalsa91/APYE.svg?branch=master)](https://travis-ci.org/adalsa91/APYE)\r\n\r\n##Hito 3: Despliegue en un Paas\r\nEn primer lugar instalamos [**Heroku CLI**](https://devcenter.heroku.com/articles/getting-started-with-python#set-up) con el siguiente comando:\r\n\r\n```bash\r\n$ wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh\r\n```\r\n\r\nUna vez instalado iniciamos sesión.\r\n\r\n![Inicio de sesión en Heroku con CLI](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito3/image1.png \"Inicio de sesión en Heroku con CLI\")\r\n\r\nAhora creamos la aplicación, en mi caso he creado una para producción y otra para pruebas.\r\n\r\n```bash\r\n$ heroku create apye-pro\r\n$ heroku create apye-stage\r\n```\r\n\r\nY los añadimos a los remotos.\r\n\r\n```bash\r\n$ git remote add pro git@heroku.com:apye-pro.git\r\n$ git remote add stage git@heroku.com:apye-stage.git\r\n```\r\n\r\nCreamos un fichero Procfile en la raíz de la aplciación para declarar que comandos deben ser ejecutados al iniciar la aplicación.\r\n```\r\nweb: gunicorn app:app\r\n\r\n```\r\n\r\nTambién tenemos que especificar la versión de Python que necesita nuestra aplicación, para ello creamos el fichero `runtime.txt` con el siguiente contenido.\r\n```\r\npython-3.4.2\r\n```\r\n\r\nEl resto de dependencias de la aplicación están en el fichero `requeriments.txt` en la raíz del proyecto y Heroku lo detectará automáticamente.\r\n\r\nDebemos definir las variables de entorno, para ello usaremos las herramientas de la CLI.\r\n```bash\r\n$ heroku config:set APP_SETTINGS=config.ProductionConfig --remote pro\r\n$ heroku config:set SECRET_KEY=SuperSecretKey --remote pro\r\n$ heroku config:set APP_SETTINGS=config.ProductionConfig --remote stage\r\n$ heroku config:set SECRET_KEY=SuperSecretKey --remote stage\r\n```\r\n\r\nYa podemos hacer un push a heroku.\r\n![Push a Heroku](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito3/image2.png \"Push a Heroku\")\r\n\r\nAhora podemos iniciar la aplicación en local con `heroku local`.\r\n\r\n![Heroku local](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito3/image5.png \"Heroku local\")\r\n\r\n```bash\r\n    heroku local web\r\n```\r\n\r\nAntes de poder lanzar la aplicación en remoto tendremos que configurar *PostgreSQL* en *Heroku*, para ello añadimos un addon tanto al servidor de stage como al pro.\r\n\r\n```bash\r\n$ heroku addons:create heroku-postgresql:hobby-dev --app apye-stage\r\n$ heroku addons:create heroku-postgresql:hobby-dev --app apye-pro\r\n```\r\n\r\nCon el comando `config` del CLI de *Heroku* podemos comprobar que efectivamente se ha creado la base de datos y la correspondiente variable de entorno.\r\n\r\n![Variable de entorno bd Heroku](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito3/image6.png \"Variable de entorno bd Heroku\")\r\n\r\nActualizamos la base de datos con las migraciones.\r\n\r\n```bash\r\n$ heroku run python manage.py db upgrade --app apye-pro\r\n$ heroku run python manage.py db upgrade --app apye-stage\r\n```\r\n\r\n![Actualización base de datos Heroku](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito3/image7.png \"Actualización base de datos Heroku\")\r\n\r\nPodemos comprobar que todo está funcionando correctamente lanzando los tests.\r\n\r\n![Resultado tests Heroku](https://raw.githubusercontent.com/adalsa91/APYE/documentacion/images/hito3/image8.png \"Resultado tests Heroku\")\r\n\r\nConectamos la aplicación de Heroku con el respositorio de GitHub para activar el despliegue automático, activando la opción de comprobocación de tests para que el despliegue no se realice hasta que Travis CI ejecute los tests con éxito.\r\n\r\n![Despliegue automático de GitHub a Heroku](images/hito3/image9.png \"Despliegue automático de GitHub a Heroku\")\r\n\r\nPor último añadimos un botón para poder desplegar el repositorio de GitHub automáticamente a Heroku, para ello creamos una fichero `app.json` en la raíz del proyecto con la descripción de la aplicación, enlace al repositorio, addons de Heroku  y variables de entorno necesarios.\r\n\r\n```\r\n{\r\n  \"name\": \"APYE\",\r\n  \"description\": \"Editor online de Python\",\r\n  \"image\": \"heroku/python\",\r\n  \"repository\": \"https://github.com/adalsa91/APYE\",\r\n  \"logo\": \"https://www.herokucdn.com/deploy/button.svg\",\r\n  \"keywords\": [\"python\", \"flask\" ],\r\n  \"addons\": [ \"heroku-postgresql\" ],\r\n  \"env\": {\r\n      \"SECRET_KEY\": {\r\n          \"description\": \"A secret key for verifying the integrity of signed cookies.\",\r\n          \"generator\": \"secret\"\r\n      },\r\n      \"APP_SETTINGS\": {\r\n          \"description\": \"Determine environment.\",\r\n          \"value\": \"config.ProductionConfig\"\r\n      }\r\n  }\r\n}\r\n```\r\nCon el siguiente fragmento en *Markdown* insertamos el botón.\r\n```\r\n[![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy)\r\n```\r\n[![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy)\r\n\r\n>Adrián Álvarez Sáez\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}